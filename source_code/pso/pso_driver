import sys
import json
sys.path.append("/home/fenics/shared/source_code/pso")
import fenicsParticle
import random

## Call this from fenics_driver? Pass in parameters?
def particle_swarm_optimization(pso_params,objFunction):


    # Assign optimization parameters
    max_iterations = pso_params["max_iterations"]
    num_particles = pso_params["num_particles"]
    dimensionality = pso_params["num_params"]
    w = pso_params["w"] # Velocity inertial parameter
    c1 = pso_params["c1"] # Weight for particle position
    c2 = pso_params["c2"] # Weight for best swarm position


    # Set up bounds for each input parameters
    # Need a mapping between parameters and dimensions of "x"


    # Initialize best global error and best global position
    best_global_error = -1
    best_global_position = []


    # Initialize swarm
    swarm = []
    for i in range(0,num_particles):
        x0 = []

        # Initialize position for particle
        for j in range(0,dimensionality):
            x0.append(random.uniform([bounds[i][0],bounds[i][1]]))

        temp_particle = fenicsParticle(x0, dimensionality, bounds)
        swarm.append(temp_particle)


    ## Begin optimization
    iter = 0

    while iter < max_iterations:

        print "iteration # " + str(iter)
        print "current minimum objective" + str(best_global_error)

        ## Iterate through swarm
        for j in range(0,num_particles):
            swarm[j].evaluate_objective(objFunction)

            # Determine if this is the best particle
            if swarm[j].current_error < best_global_error or best_global_error == -1:
                best_global_position = list(swarm[j].position)
                best_global_error = float(swarm[j].current_error)

        ## Update velocities and position (start new loop to make sure
        # we are using the best global position after objective is evaluated for
        # entire swarm)
        for j in range(0,num_particles):
            swarm[j].update_particle_velocity(w,c1,c2,best_global_position)
            swarm[j].update_particle_position()

        iter += 1

    return(best_global_position,best_global_error)
